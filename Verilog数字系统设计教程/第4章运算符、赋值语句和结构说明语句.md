# 第四章 运算符、赋值语句和结构说明语句

## 概述
在本章中我们将学习Verilog语法中关于各种运算符、赋值语句、结构说明语句等基本语法要素。这些内容看起来简单，但有很多地方与C语言不同，例如拼接运算符、缩减运算符、阻塞和非阻塞赋值运算符和结构说明语句中的并行块等。

## 4.1 逻辑运算符
在Verilog HDL语言中存在3种逻辑运算符:
(1) && 逻辑与
(2) || 逻辑或
(3) !  逻辑非

`&&`和`||`是双目运算符。
`!`是单目运算符

逻辑运算符种`&&`和`||`的优先级低于关系运算符，`!`高于算数运算符

```verilog
a == b || a == c;
!a || a > b
```

## 4.2 关系运算符
关系运算符共有以下4种:
(1) a < b
(2) a > b
(3) a <= b
(4) a >= b

在进行关系运算时，如果声明的关系是假的(flase)，则返回值是0。如果某个操作数的值不定，则关系是模糊的，返回值是不定值。

所有的关系运算符有着相同的优先级。关系运算符的优先级低于算数运算符的优先级。

## 4.3 等式运算符
在Verilog HDL语言存在4种等式运算符:
(1) ==    // 等于
(2) !=    // 不等于
(3) ===   // 等于
(4) !===  // 不等于

**注意:求反号、双等号、三个等号之间不能有空格。**

这四个运算符都是双目运算符，它要求有两个操作数。

`==`和`！=`又称为逻辑等式运算符。
由于操作数中的某些位可能是不定值和高阻值z，结果可能为不定值x。

`===`和`!===`又称为case等式运算符
它在对操作数进行比较时对某些位的不定值x和高阻值z也进行比较，两个操作数必须完全一致，其结果才是1，否则是0。

这4个等式运算符的优先级别是相同的。

## 4.4 移位运算符
在Verilog HDL中有两种移位运算符:
(1) `<<`
(2) `>>`

这两种移位运算都用0来填补移出的空位。

## 4.5 位拼接运算符
在Verilog HDL语言中有一个特殊的运算符,位拼接运算符
(1) `{}`

这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。其使用方法如下:

{信号1的某几位，信号2的某几位---}

`a, b[3:0], w, 3'b101`

在位拼接表达式中不允许存在没有指明位数的信号。这是因为在计算拼接信号位宽的大小时必须知道其中每个信号的位宽。

位拼接可以用重复法来简化表达式:
`{4{w}}`  // 等同于`{w,w,w,w}`

位拼接还可以用嵌套的方式来表达:
`{b, {3{a, b}}}` // 等同于`{b, a, b, a, b, a, b}`

用于表示重复的表达式，如上例中的4和3，必须是常数表达式。

## 4.6 缩减运算符
缩减运算符(reduction operator)是单目运算符，也有与或非运算。其与或非运算规则类似于位运算符的与或非规则，但其运算过程不同。

位运算是对操作数的相应位进行与或非操作，原操作数是几位，运算结果也是几位。

而缩减运算则不同，缩减运算是对单个操作数进行与或飞递推运算，最后的结果是1位的二进制数。

缩减运算的具体运算过程是这样的:
(1) 第一步先将操作数的第1位与第2位进行与或非运算。
(2) 第二步将运算结果与第3位进行与或非运算。
以此类推，直至最后一位。

```verilog
reg [3:0] B;
reg C;
    C = &B;
```

相当于
`C = ((B[0] & B[1]) & B[2]) & B[3]`;

## 4.7 优先级别
下面对各种运算符的优先级别关系做一总结:
(1) `! ~`               // 高
(2) `* / %`
(3) `+ -`
(4) `<< >>`
(5) `< <= > >=`
(6) `== != === !===`
(7) `&`
(8) `^ ^~`
(9) `!`
(10)`|`
(11)`&&`
(12)`||`
(13)`?:`                // 低

## 4.8 关键词

### 4.9.1 赋值语句
在Verilog HDL语言中，信号有两种赋值方式:

#### 1. 非阻塞(Non_Blocking)赋值方式(如b<=a;)
(1) 在语句块中，上面语句所赋的变量值不能立即就为下面的语句所用;
(2) 块结束后才能完成这次赋值操作，而所赋的变量是上一次赋值得到的；
(3) 在编写可综合的时序逻辑模块时，这是最常用的赋值方法。

**注意:非阻塞赋值`<=`与小于等于符看起来相同，但意义完全不同。**
#### 2. 阻塞(Blocking)赋值方式(如b=a;)
(1) 赋值语句执行完后，块才结束；
(2) b的值在赋值语句执行完后立刻就改变的；
(3) 在时序逻辑中使用时，可能会产生意想不到的结果。

非阻塞赋值方式和阻塞赋值方式的区别常给设计人员带来问题。

问题主要是对`always`块内的reg型信号的赋值方式不易把握。

非阻塞赋值`b<=a;`，这种方式的赋值并不是马上执行的，也就是说`always`块内的下一条语句执行后，b并不等于a，而是保持原来的值，always块结束后，才进行赋值。

阻塞赋值`b=a`,这种方式的赋值是马上执行的，也就是说执行下一条语句时，b已经等于a。

### 4.9.2 块语句
块语句通常用来将两条或多条语句组合在一起，使其在格式上看更像一条语句。

块语句有两种:
一种是begin_end语句，通常用来标识顺序执行的语句，用它来标识的块称为顺序块；
另一种是fork_join语句，通常用来标识并行执行的语句，用它来标识的块称为并行块。

#### 1. 顺序块
顺序块有以下特点:
(1) 块内的语句是按顺序执行的，即只有上面一条语句执行完毕后下面的语句才能执行。
(2) 每条语句的延迟时间是相对于前一条的仿真时间而言的。
(3) 知道最后一条语句执行完，程序流程控制才跳出该语句块。

顺序块的格式如下:
```verilog
begin
    语句1；
    语句2；
    ···
    语句n
end
```
或
```verilog
begin:块名
    块内声明语句
    语句1；
    语句2；
    ···
    语句n；
end
```

其中:
(1) 块名即该块的名字，一个标识名。
(2) 块内声明语句可以是参数声明语句、reg型变量声明语句、interger型变量声明语句和real型变量声明语句。

#### 2. 并行块
并行块有以下4个特点:
(1) 块内语句是同时执行的，即程序控制流程已进入到该并行块，块内语句则开始同时并行地执行。
(2) 块内每条语句地延迟时间是相对于程序流程控制进入到块内地仿真时间地。
(3) 延迟时间是用来给赋值语句提供执行时序地。
(4) 当按时间时序排序在最后地语句执行完后或一个disable语句执行时，程序控制流程跳出该程序块。

并行块地格式如下:
```verilog
fork
    语句1；
    语句2；
    ···
    语句n;
join
```
或
```verilog
fork:块名
块内声明语句
    语句1；
    语句2；
    ···
    语句n；
join
```

其中:
(1) 块名即标识该块地一个名字，相当于一个标识符。
(2) 块内说明语句可以是参数说明语句、reg型变量声明语句、integer型变量声明语句、real型变量声明语句、time型变量声明语句和时间(event)说明语句。

#### 3. 块名
在Verilog HDL语言中，可以给每个块取一个名字，只需将名字加载关键词begin或fork后面即可。这样做的原因有以下几点:
(1) 可以在块内定义局部变量，即只在块内使用的变量。
(2) 可以允许块被其他语句调用，如disable语句。
(3) 在Verilog语言里，所有地变量都是静态地，即所有地变量都只有一个唯一地存储地址，因此进入或跳出块并不影响存储在变量内地值。

基于以上原因，块名就提供了一个在任何仿真时刻确认变量值的方法。

#### 4. 起始时间和结束时间
在并行块和顺序块中都有一个起始时间和结束时间的概念。对于顺序块，起始时间就是第一条语句开始被执行的时间，结束时间就是最后一条语句执行完的时间。而对于并行块来说，起始时间就是对于块内所有的语句是相同的，即程序流程控制进入该块的时间，其结束时间是按时间排序v在最后的语句执行结束的时间。

当一个块嵌入另一个块时，块的起始时间和结束时间是很重要的。至于跟在块后面的语句只有在该块的结束时间到了才开始执行。也就是说，只有该块完全执行完后，后面的语句才可以执行。

在fork_join块内，各条语句的顺序不必按顺序给出，因此在并行块里，各条语句在前还是在后是无关紧要的。

## 小结
在本章中要注意几个问题:
(1) 无论是逻辑运算、逻辑比较还是逻辑等式等逻辑操作一般发生在条件判断语句中，其输出只有1或0。
(2) 位拼接运算符{}在C语言中没有定义，但在Verilog中是一种很有用的语法。可以借助于拼接运算符用一个信号名来表示由多位信号组成的复杂信号，其中每个共信号可以由自己独立的名字和位宽。例如控制信号，可以用如下的位拼接来表示
`assign control = {read, write, sel{2:0}, halt, load_instr, ···};`
(3) 缩减运算符也是C语言所没有的。
(4) 阻塞和非阻塞赋值也是C语言所没有的特别是在编写可综合风格的模块中要加以注意。阻塞语句，如果没有写延迟时间看起来是在同一时刻运行，但实际上是有先后的，即在前面的先运行，然后再运行下面的语句，阻塞语句的次序与逻辑行为有很大的关系。而非阻塞赋值的就不同了，再begin end之间的所有非阻塞语句都在同一时刻被复制，因此逻辑行为与非阻塞语句的次序就没有关系。在硬件实现时这两者有很大的不同。
(5) begin end块语句与C语言中的大括号对类似，而fork join语句在C语言中没有定义，但其定义并不难理解。在测试模块中，描述测试信号常在initial和always过程块中使用并行块。这种描述方法，由于时间关系只与起点比较，有时这样表达比较容易和清楚。