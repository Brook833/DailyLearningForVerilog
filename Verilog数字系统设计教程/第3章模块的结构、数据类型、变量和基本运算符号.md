# 第三章 模块的结构、数据类型、变量和基本运算符号

## 概述
在本章中将详细的学习Verilog语法中关于模块的结构、数据类型、变量和基本运算符号等语法要素。

## 3.1 模块的结构
Verilog的基本设计单元是"模块"(block)。一个模块是由两部分组成的，一部分描述接口，另一部分描述逻辑功能，即定义输入时如何应i想输出的。

```verilog
module block(a,b,c,d)
    input a,b;
    output c,d;

    assign c = a|b;
    assign d = a&b;
endmodule
```

模块中的第二三行说明接口的信号流向，第四五行说明了模块的逻辑功能。

从这一例子可以看出，Verilog结构位于在module和endmodule声明语句之间，每个Verilog程序包括4个主要部分:端口定义、I/O说明、内部信号声明和功能定义。

### 3.1.1 模块的端口定义
模块的端口声明了模块的输入输出口。其格式如下:
`module 模块名(口1，口2，--)`
模块的端口表示的是模块的输入和输出口名，也就是说，它与别的模块联系端口的标识。

在模块备引用时，在引用的模块中，有些信号要输入到被引用的模块中，有的信号需要从被引用的模块中取出来。在引用模块时可以用两种方法连接:
> + (1)在引用时，严格按照模块定义的端口顺序来连接，不用表明原模块定义时规定的宽口名，例如:
>> + 模块名(连接端口1信号名，连接端口2信号名，--);
> + (2)在引用时，用"."符号，表明原模块是定义时规定的端口名，例如:
>> + 模块名(.端口1名(连接信号1名)，端口2名(连接信号2名)，---)；

这样表示的好处在于可以用端口名与被引用的模块的端口相对应，而不必严格按端口顺序对应，提高了程序的可读性和可以执行。

例如:
```verilog
MyDesignMK M1(.sin(Serialln), .pout(ParallelOut), --);
```

其中，.sin和.punt都是M1的端口名，而M1则是与MyDesignMK完全一样的模块。MyDesignMK已经在另一个模块中定义过，它有两个端口，即sin和pout。与sin口连接的信号为Serialln，与pout连接的信号名为ParallelOut。

### 3.1.2 模块内容
模块的内容包括I/O说明、内部信号声明和功能定义。

#### 1. I/O说明的格式
输入口:
input[信号位宽-1:0]端口名1;
input[信号位宽-1:0]端口名2;
输出口:
output[信号位宽-1:0]端口名1;
output[信号位宽-1:0]端口名2;
输入/输出口:
input[信号位宽-1:0]端口名1;
input[信号位宽-1:0]端口名2;

I/O说明也可以写在端口声明语句里。其格式如下:
module module_name(input port1, input port2, ..., output port1)；

#### 2. 内部信号说明
在模块内用到的和与端口有关的wire和reg类型变量的声明。

reg[width-1:0]R变量1, R变量2;
wire[width-1:0]W变量1，W变量2;

#### 3. 功能定义
模块中最重要的部分是逻辑功能定义部分。有3种方法可在模块种产生逻辑。

(1) 用"assign"声明语句
`assign a = b & c;`

这种方法的句法很简单，只需写一个"assign"，后面在加一个方程式即可。李忠的方程式描述了一个有两个输入的与门。

(2) 用实例元件
`and #2 ul(q, a, b);`

采用实例元件的方法像在电路图输入方式下调入库元件一样，键入元件的名字和相连的引脚即可。这表示在设计中用到一个跟与门(and)一样的名为ul的与门，其输入端为a、b，输出为q。输出延迟为2个时间单位。==要求每个实例元件的名字必须是唯一的，以避免与其他调用与门(and)的实例混淆。==

(3) 用"always"块
`always @(posedge clk or posedge clr);`

begin
    if(clr) q<= 0;
    else if (en) q<= d;
end

采用"assign"语句是描述组合逻辑最常用的方法之一。而"always"块既可用于描述组合逻辑，也可描述时序逻辑。用"always"块的例子生成了一个带有一部清除端的D触发器。"always"块可用很多种描述手段来表达逻辑，例如上例就用了if else语句来表达逻辑关系。如按一定的风格来编写"always"块，可以通过综合工具把源代码自动综合成用门级结构表示的组合或时序电路。

### 3.1.3 理解要点
如果用Verilog模块实现一定的功能，首先应该清除哪些是同时发生的，哪些是顺序发生的。

在`always`模块内,逻辑是按照指定的顺序执行的。`always`块种的语句称为顺序语句，因为它们都是顺序执行的。所以，`always`块也成为"过程块"。

请注意，两个或更多的`always`模块都是同时执行的，而模块内部的语句是顺序执行的。看一下"always"内的语句，就会明白它是如何实现功能的。if else if 必须顺序执行，否则其功能没有任何意义。

### 3.1.4 要点总结
Verilog的初学者一定要深入理解并记住:
(1)在Verilog模块中所有过程块(如:initial、always块)、连续赋值语句、实例引用语句都是并行的；
(2)它们表示的是一种通过变量名互相连接的关系;
(3)在同一模块中这三者出现的先后秩序没有关系；
(4)只有连续赋值语句assign和实例引用语句可以独立于过程块而存在于模块的功能定义部分。

以上4点和C语言有很大的不同。许多C语言类似的语句只能出现在过程块中，而不能随意出现在模块功能定义的范围内。

## 3.2 数据类型及其常量和变量
Verilog HDL中总共有19种数据类型。数据类型是用来表示数字电路硬件中的数据储存和传送元素的。在教材中先介绍4个最基本的数据类型，他们是:

reg型、wire型、integer型和parameter型。

其他类型是:

large型、medium型、scalared型、time型、small型、tri型、tril型、trior型、trireg型、vectored型、wand型和wor型。

这14种数据类型除time型外都与基本逻辑单元建库有关，与系统设计没有很大的关系。

Verilog HDL语言中也有常量和变量之分，它们分别属于以上这些类型。

### 3.2.1 常量
在程序运行过程中，其值不能被改变的量称为常量。下面首先对Verilog HDL语言中使用的数字及其表示方式进行介绍。

#### 1. 数字
(1) 整数
在Verilog HDL中，整数常量即整常数有以下4中进制表示形式:
> + 二进制整数(b或B);
> + 十进制整数(d或D);
> + 十六进制整数(h或H);
> + 八进制整数(o或O);

数字表达方式有以下3种:
> + <位宽><进制><数字>，这是一种全面的描述方式。
> + <进制><数字>，数字的位宽采用默认位宽(这由具体的及其系统决定，但至少32位)。
> + <数字>,采用默认进制(十进制)。

在表达式中，位宽指明了数字的精确位数。例如:一个4位二进制的数字的位宽为4，一个4位十六进制的位宽为16。

(2) x和z值
在数字电路中，x代表不定值，z代表高阻值。一个x可以用来定义十六进制数的4位二进制数的状态，八进制的3位，二进制数的1位。z的表示方式同x类似。z还有一种表达方式是可以写作"?"。在使用case表达式时建议使用这种写法，以提高程序的可读性。

(3) 负数
一个数字可以被定义位负数，只需在位宽表达式前加一个减号，减号必须写在数字定义表达式的最前面。

**注意：减号不可以放在位宽和进制之间，也不可以放在进制和具体的数之间**

-8'd5   // 表达式代表5的补数(用八位二进制数表示)
8'd-5   // 非法格式

(4) 下划线(underscore_)
下划线可以用来分隔开数的表达以提高程序可读性。他不可以用在位宽和进制处，只能用在具体的数字之间。

16'b1010_1011_1111_1010
8'b_0011_1010   //非法格式

当常量不说明位数时，默认值是32位，每个字母用8位的ASCII值表示。

10 = 32'd10 = 32'b1010
1 = 32'd1 = 32'b1
-1 = -32'd1 = 32'hFFFFFFFF
'BX = 32'BX = 32'BXX..XX
"AB" = 16'B01000001_01000010

#### 2. 参数(parameter)型
在Verilog HDL中用parameter来定义常量，即用parameter来定义一个标识符代表一个常量，称为符号常量，即标识符形式的常量，采用标识符代表一个常量可提高程序的可读性和可维护性。parameter型数据是一种常数型的数据，其说明格式如下:

parameter 参数名1 = 表达式， 参数名2 = 表达式...

parameter是参数型数据的确认符。确认符后跟着一个用逗号分隔开的赋值语句表。在每一个赋值语句的右边必须是一个常数表达式。也就是说，该表达式只能包含数字或先前已定义过的参数。

parameter msb = 7;
parameter e = 25, f = 29;
parameter r = 5.7;
parameter byte_size = 8, byte_msb = byte_size - 1;
parameter average_delay = (r+f)/2;

参数型常量经常用于定义延迟时间和变量宽度。在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数。

### 3.2.2 变量
变量是一种在程序运行过程中其值可以改变的量，在Verilog HDL中变量的数据类型有很多种，这里只对常用的几种进行介绍。

网络数据类型表示结构实体(例如门)之间的物理连接。

==网络类型的变量不能存储值，而且它必须受到驱动器(例如门或连续赋值语句,assign)的驱动。如果没有驱动器连接到网络类型的变量上，则该变量就是高阻的，即其值为z。常用的网络数据类型包括wire型和tri型==

这两种变量都是用于连接器件单元，他们具有相同的语法格式和功能。之所以提供这两种名字来表达相同的概念，其目的是为了与模型中所使用的变量的实际情况相一致。

wire型变量通常是用来表示单个门驱动或者连续赋值语句驱动的网络型数据。

tri型变量则用来表示多驱动器驱动的网络型数据。

如果wire型或tri型变量没有定义逻辑强度(logic strength)，在多驱动源的情况下，逻辑值会发生冲突，从而产生不确定值。

#### 1. wire型
wire型数据通常用来表示用以assign关键字指定的组合逻辑信号。Verilog程序模块中输入，输出信号默认时自动定义为wire型。wire型信号可以用作任何方程式的输入，也可以用作"assign"语句或实例元件的输出。

wire型信号的格同reg信号的格式很类似。

`wire[n-1:0] 数据名1,数据名2;`

wire是wire型数据的确认符;[n-1:0]代表该数据的位宽，即该数据有几位；最后跟着的是数据的名字。声明语句的最后要用分号表示语句结束。

#### 2. reg型
寄存器是数据存储单元的抽象。寄存器数据类型的关键字是reg。通过赋值语句可以改变寄存器存储的值，其作用与改变触发器储存的值相当。Verilog HDL语言提供了功能强大的结构语句，使设计者能有效地控制是否执行这些赋值语句。这些控制结构用来描述硬件触发条件，例如时钟的上升沿和多路器的选通信号。

==reg类型数据的默认初始值为不定值x==

reg型数据常用来表示"always"模块内的指定信号，常代表触发器。通常，在设计中要由"always"模块通过使用行为描述语句来表达逻辑关系。在"always"模块内被赋值的每一个信号都必须定义成reg型。

reg型数据的格式如下:

`reg[n-1:0] 数据名1，数据名2;`

reg使reg类型数据的确认标记符;[n-1]代表该数据的位宽，即该数据有几位(bit);最后跟着的是数据的名字。声明语句的最后要用分号表示语句结束。

reg型数据的默认初始值是不定值。reg型数据可以赋正值，也可以赋负值。

==但当一个reg型数据是一个表达式中的操作数时，它的值被当作是无符号值，即正值。==

例如,当一个4位的寄存器用作表达式中的操作数时，如果开始寄存器被赋予值-1，即在表达式中进行运算时，被认为是+15。

**注意:reg型只表示被定义的信号将用在"always"模块中，理解这一点很重要。并不是说reg型信号一定是寄存器或触发器的输出。**

#### 3 memory型
Verilog HDL通过reg型变量建立数组来对存储器建模，可以描述RAM型存储器、ROM型存储器和reg文件。数组中的每一个单元通过一个数组索引进行寻址。在Verilog语言中没有多维数组存在。memory型数据是通过扩展reg型数据的地址范围来生成的。

`reg[n-1:0] 存储器名[m-1:0];`

在这里，reg[n-1:0]定义了存储器中每一个存储单元的大小，即该存储单元是一个n位的寄存器;存储器名后的[m-1:0]或[m:1]即定义了该存储器中有多少个这样的寄存器;最后用分号结束定义语句

`reg[7:0] mema[255:0]`

这个例子定义了一个名叫mema的存储器，该存储器有256个8位的存储器。该存储器的地址范围是0-255。

**注意:对存储器进行地址索引的表达式必须是常数表达式**

另外，在同一个数据声明语句里，可以同时定义存储器型数据和reg型数据。

```verilog
parameter wordsize = 16, memsize = 256;
reg[wordsize-1: 0] mem[memsize-1:0],writereg,readreg;
```

尽管memory型数据和reg型数据的定义格式很相似，但要注意其不同之处。如一个由n个1位寄存器构成的存储器组是不同于一个n位的寄存器的:

```verilog
reg[n-1:0] rega;    // 一个n位的寄存器
reg mema[n-1:0];    // 一个由n个1位的寄存器构成的存储器组
```

如果相对memory中的存储单元进行读写操作，必须指定该单元在存储器中的地址。

`mema[3] = 0;`

进行寻址的地址索引可以是表达式，这样就可以对存储器中的不同单元进行操作。表达式的值可以取决于电路中其他的寄存器的值。

## 3.3 运算符及其表达式
Verilog HDL语言的运算符范围很广，其运算符按其功能可分为以下几类:
(1) 算数运算符`+,-,*,/,%`
(2) 赋值运算符`=,<=`
(3) 关系运算符`>,<,>=,<=`
(4) 逻辑运算符`&&，||，!`
(5) 条件运算符`?:`
(6) 位运算符`~,|,&,^,^~`
(7) 移位运算符`<<,>>`
(8) 拼接运算符`{}`
(9) 其他

在Verilog HDL语言中运算符所带的操作数是不同的，按其所带操作数的个数运算符可分为3种:
(1) 单目运算符
(2) 双目运算符
(3) 三目运算符

### 3.3.1 基本的算数运算符
在Verilog HDL语言中，算数运算符又称为二进制运算符，共有下面几种:
(1) `+`
(2) `-`
(3) `*`
(4) `/`
(5) `%`

在进行整数除法运算时，结果值要略去小数部分，只取整数部分;而进行取模运算时，结果值的符号位采用模运算时第一个操作数的符号位。

**注意:在进行算术运算操作时，如果某一个操作数有不确定的值x，则整个结果也为不定值x。**

### 3.3.2 位运算符
