# 第六章 结构语句、系统任务、函数语句和现实系统任务

## 概述
在本章中将学习Verilog语法中两种结构语句以及如何定义和使用任务与函数，还有几个常用系统任务的用法。除了函数之外，这些语句在C语言中从来都没有定义过。特别需要注意的是，函数虽然在C语言中有过定义，但与Verilog的函数定义则完全不同。我们一定要注意这些语句所代表的物理意义，有意识地把结构语句、任务、函数与虚拟测试信号的生成或硬件电路结构联系起来。

## 6.1 结构说明语句
Verilog语言中的任何过程模块都从属于以下4种结构的说明语句:
(1) initial说明语句;
(2) always说明语句;
(3) task说明语句;
(4) function说明语句。

一个程序模块可以有多个initial和always过程块。每个initial和always说明语句在仿真的一开始同时立即开始执行。initial语句只执行一次，而always语句则是不断地重复活动着，直到仿真过程结束。但always语句后跟着的过程块是否运行，则要看它的触发条件是否满足，如满足则循行过程块一次，再次满足则再运行一次，直至仿真过程结束。

在一个模块中，使用initial和always语句的次数是不受限制的，它们都是同时开始运行的。

task和function语句可以在程序模块中的一处或多处调用。

### 6.1.1 initial语句
initial语句的格式如下:
```verilog
initial
    begin
        语句1；
        语句2；
        ...
    end
```

**注意:一个模块中可以有多个initial块，它们都是并行运行的。initial块常用于测试文件和虚拟模块的编写，用来产生仿真测试信号和设置信号记录等仿真环境。**

### 6.1.2 always语句
always语句在仿真过程中是不断活动着的。但always语句后跟着的过程块是否执行，则要看它的触发条件是否满足，如满足则运行过程块一次；如不断满足，则不断地循环执行。其声明格式如下:

`always <时序控制> <语句>`

always语句由于其不断活动的特性，只有和一定的时序控制结合在一起才有用。如果一个always语句没有时序控制，则这个always语句将会使仿真器产生死锁。

#### 1. always块的OR事件控制
有时，多个i新年好或者事件中任意一个发生的变化都能触发语句或语句块的执行。在VerIlog语言中，可以使用"或"表达式来表示这种情况。由关键词"or"连接的多个事件名或者信号名组成的列表称为敏感列表。关键词"or"被用来标识这种关系，或者使用"，"来代替。

如果输入变量很多，那么编写敏感列表会很繁琐并且容易出错。针对这种情况，Verilog提供另外两个特殊的符号`@ *`和`@(*)`，它们都表示对其后面语句块中所有输入变量的变化是敏感的。

#### 2. 电平敏感时序控制
起那面所讨论的事件控制都需要等待信号值的变化或者事件的触发，使用符号@和后面的敏感列表来表示。Verilog同时也允许使用另外一种形式表示的电平敏感时序控制。VerIlog用关键字wait来表示等待电平敏感的条件为真。

```verilog
always
    wait (count_enable) # 20 count = count + 1;
```

## 6.2 task和function说明语句
task和function说明语句分别用来定义任务和函数，利用任务和函数可以把一个很大的程序模块分解成许多较小的任务和函数便于理解和调试。输入、输出和总线信号的值可以传入、传出任务和函数。任务和函数往往还是大的程序模块中在不同地点多次用到的相同程序段。学会使用task和function语句可以简化程序的结构，是程序明白易懂，是编写较大型模块的基本功。

### 6.2.1 task和function说明语句的不同点
任务和函数有些不同，主要的不同有以下4点:
(1) 函数只能与主模块共用同一个仿真时间单位，而任务可以定义自己的仿真时间单位。
(2) 函数不能启动任务，而任务能启动其他任务和函数。
(3) 函数至少要有一个输入变量，而任务可以没有或有多个任何类型的变量。
(4) 函数返回一个值，而任务则不返回值。

函数的目的通过返回一个值来响应输入信号的值。任务却能支持多种目的，能计算多个结果值，这些结果值只能通过被调用的任务的输出或总线端口送出。Verilog HDL模块使用函数时是把它当作表达式中的操作符，这个操作的结果值就是这个函数的返回值。

### 6.2.2 task说明语句
如果传给任务的变量值和任务完成后接受结果的变量已定义，就可以用一条语句启动任务，任务完成以后控制就传回启动过程。如任务内部有定时控制，则启动的时间可以与控制返回的时间不同。任务可以启动其他的任务，其他任务又可以启动别的任务，可以启动的任务数是没有限制的。不管有多少任务启动，只有当所有的启动任务完成以后，控制才能返回。

(1) 任务的定义

```verilog
task <任务名>
    <端口及数据类型声明语句>
    <语句>
endtask
```

这些声明语句的语法与模块定义中的对应声明语句的语法是一致的。
(2) 任务的调用及变量的传递
任务的调用:

```verilog
    <任务名>(端口1, 端口2，···);
```

任务定义:
```verilog
task my_task;
    input a, b;
    inout c;
    output d, e;
    <语句>
endtask
```

任务调用:

```verilog
    my_task(v,w,x,y,z);
```

### 6.2.3 function说明语句
函数的目的是返回一个用于表达式的值。
(1) 定义函数的语法:

```verilog
function <返回值的类型或范围> (函数名);
    <端口说明语句>
    <变量类型说明语句>
    begin
        <语句>
    end
endfunction
```

(2) 从函数返回的值:函数的定义蕴含声明了与函数同名的、函数内存的寄存器。如在函数的声明语句中<返回值的类型或范围>为默认，则这个寄存器是一位的;否则是与函数定义中<返回值的类型或范围>一致的寄存器。函数的定义把函数返回值所赋值寄存器的名称初始化为与函数同名的内部变量。

(3) 函数的调用:函数的调用是通过将函数作为表达式中的操作数来实现的。其调用格式如下:

```verilog
<函数名>(<表达式>，···<表达式>)
```

其函数名作为确认符。

(4) 函数的使用规则:与任务相比较函数的使用有较多的约束，下面给出的是函数的使用规则:
a: 函数的定义不能包含有任何的时间控制语句，即任何用#、@或wait来标识的语句。
b: 函数不能启动任务
c: 定义函数时至少要有一个输入参量
d: 在函数的定义中必须有一条赋值语句给函数中的一个内部变量赋以函数的结果值，该内部变量具有和函数名相同的名字。

### 6.2.5 自动(递归)函数
Verilog中的函数是不能够进行递归调用的。设计模块中若某函数在两个不同的地方被同时并发调用，由于这两个调用同时对同一块地址空间进行操作，那么计算结果将是不确定的。

若在函数声明时使用了关键字`automatic`，那么该函数将成为自动的或可递归的，即仿真器为每一次函数调用动态地分配新的地址空间，每一个函数调用对各自的地址空间进行奥做。因此，自动函数中声明的局部变量不能通过层次名进行访问。而自动函数本身可以通过层次名进行调用。

### 6.2.6 常量函数
常量函数实际上是一个带有某些限制的Verilog函数。这种函数能够用引用复杂的值，因而可用来代替常量。

### 6.2.7 带符号函数
带符号函数的返回值可以作为带符号数进行运算。

## 6.3 关于使用任务和函数的小结
在前述中已对Verilog行为建模中使用的任务和函数进行了讨论，可概括为以下特点:
(1) 任务和函数都是用来对设计中多处使用的公共代码进行定义；使用任务和函数可以将模块分割成许多个可独立管理的字单元，增强了模块的可读性和可维护性；它们和C语言中的子程序起相同的作用。
(2) 任务可以具有任意多个输入、输入/输出(inout)和输出变量；在任务中可以使用延迟、事件和时序控制结构，在任务中可以调用其他的任务和函数。
(3) 可重入任务使用关键字automatic进行定义，它的每一次调用都对不同的地址空间进行操作。因此在被多次并发调用时，它仍然可以获得正确的结果。
(4) 函数只能有一个返回值，并且至少要有一个输入变量；在函数中不能使用延迟、事件和时序控制结构，但可以调用其他函数，不能调用任务。
(5) 当声明函数时，Verilog仿真器都会隐含地声明一个同名地寄存器变量，函数的返回值通过这个寄存器传递回调用处。
(6) 递归函数使用关键字automatic进行定义，递归函数的每一次调用都拥有不同的地址空间。因此对这种函数的递归调用和并发调用可以得到正确的结果。
(7) 任务和函数都包含在设计层次之中，可以通过层次名对他们进行调用。

## 6.4 常用的系统任务
本节中将讨论Verilog语言中一些常用的系统任务及各自适用不同的场合。还将讨论用于文件输出、显示层次、选通显示(strobing)、存储器初始化和值变转储的系统任务。

### 6.4.1 $display 和 $write 任务
格式:
```verilog
    $display(p1, p2, ···);
    $write(p1, p2, ···);
```

这两个参数和系统任务的作用是用来输出信息的，及将参数p2到pn按照参数p1给定的格式输出。参数p1通常称为"格式控制"，参数p2至pn通常称为"输出表列"。这两个任务的作用基本相同。$display自动的在输出后进行换行，$write则不是这样。如果想在一行里输出多个信息，可以使用$display。在$display和$write中，其输出格式控制是用双引号括起来的字符串，它包括以下两种信息:

(1) 格式说明,由"%"和格式字符组成。它的作用是将输出的数据转换成指定的格式输出。格式说明总是由"%"字符开始的。对于不同类型的数据用不同的格式输出。
(2) 普通字符，即需要原样输出的字符。其中一些特殊的字符可以通过转换序列来输出。表中的字符形式用于格式字符串参数中，用来显示特殊的字符。

输出数据的显示宽度:在$display中，输出列表中数据的显示宽度是自动按照输出格式进行调整的。这样在显示输出数据时，在经过格式转换以后，总是用表达式的最大可能至所占的位数来显示表达式的当前值。在用十进制数格式输出时，输出结果前面的0值用空格来代替。对于其他进制，输出结果前面的0仍然显示出来。例如对于一个值的位宽为12位的表达式，如按照十六进制数输出，则输出结果占3个字符的位置；

如果输出列表中表达式的值包含有不确定的值或高阻值，其结果输出遵循以下规则:
(1) 在输出格式为十进制的情况下:
a: 如果表达式值的所有位均为不定制，则输出的结果为小写的x。
b: 如果表达式值得所有位均为高阻值，则输出的结果为小写的z。
c: 如果表达式的部分位位不定制，则输出的结果为大写的X。
d: 如果表达式值的部分为高阻值，则输出结果为大写的Z。
(2) 在输出格式为十六进制和八进制的情况下:
a: 每4位二进制数位一组代表一位十六进制数。
b: 如果表达式相对应的某进制数的所有位均为不定值，则该位进制数的输出的结果为小写的x。
c: 如果表达式相对应的某进制数的所有位均为高阻值，则该位进制数的输出的结果为小写的z。
d: 如果表达式相对应的某进制数的部分位不定值，则该位进制数的输出的结果为大写的X。
e: 如果表达式相对应的某进制数的部分位高阻值，则该位进制数的输出的结果为大写的Z。

### 6.4.2 文件输出
Verilog的结果通常输出到标准输出和文件verilog.log中。可以将Verilog的输出重新定向到选择的文件。

#### 1.打开文件
文件可以用系统任务$open打开。
用法:`$fopen("<文件名>")`

#### 2.写任务
系统任务$fdisplay、$fmonitor、$fwrite和$fstrobe都用于写文件。

**注意:这些任务在语法上与常规系统任务$display、$monitor等类似，但是它们提供了额外的写文件功能**

#### 3.关闭文件
文件可以用系统任务$fclose来关闭。
用法:`$fclose(<文件描述符>)`

文件一旦被关闭就不能再写入。

### 6.4.3 显示层次
通过任何显示任务，比如$display、$write、$monitor或者$strobe任务中的%m选项的方式可以显示任何级别的层次，这是非常有用的选项。

### 6.4.4 选通显示
选通显示(Strobing)由关键字为$strobe的系统任务完成。这个任务与$display任务除了一点小差异外，其他非常相似。如果许多其他语句与$display任务在同一个时间单位执行，那么这些语句与$display任务的执行顺序是不确定的。如果使用$strobe，该语句总是在通识课的其他赋值语句执行完成之后才执行。因此，$strobe提供了一种同步机制，它可以确保所有在同一时钟沿赋值的其他语句再执行完毕之后才显示数据。

### 6.4.5 值变转储文件