# 3.2 Verilog时延
## 关键词: 时延，惯性时延
连续赋值延迟语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时。

时延一般是不可综合的。

寄存器的时延也是可控制的，这部分在时许控制里加以说明。
连续赋值时延一般可分为普通赋值时延，隐式时延，声明时延。
下面3个例子实现的功能是等效的，分别对应3中不同连续赋值时延的写法。

```verilog
// 普通时延，A&B计算结果延时10个时间单位赋值给Z
wire Z, A, B;
assign #10  Z = A & B;
```

```verilog
// 隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值
wire A, B;
wire #10    Z = A & B;
```

```verilog
// 声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间，除非门级建模中，一般不推荐使用此类方法建模
wire A, B;
wire #10 Z;
assign Z = A & B;
```

## 惯性时延
在上述例子中，A或B任意一个变量发生变化，那么在Z得到新的值之前，会有10个时间单位的时延。如果在这10个时间单位内，即在Z获取新的值之前，A或B任意一个值又发生了变化，那么计算Z的新值时会取A或B当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响。

因此仿真时，时延一定要合理设置，防止某些信号不能进行有效的延迟。

对一个有延迟的与门逻辑进行时延仿真。

```verilog
module time_delay_module(
    input   ai, bi,
    output  so_lose, so_get, so_normal);

    assign #20  so_lose = ai & bi;
    assign #5   so_get  = ai & bi;
    assign      so_normal = ai & bi;
endmodule
```