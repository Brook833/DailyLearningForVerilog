# 4.2 Verilog过程赋值
## 关键词:阻塞赋值，非阻塞赋值，并行
过程性赋值是在initial或always语句块里的赋值，复制对象是寄存器、整数、实数等类型。
这些变量在被赋值后，其值将保持不变，直到重新被赋予新值。
连续性复制总是处于激活状态，任何操作数的改变都会影响表达式的结果;
过程赋值只有在语句执行时，才会起作用。这是连续性赋值的区别。

Verilog过程赋值包括2种语句:阻塞赋值与非阻塞赋值。

## 阻塞赋值
阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。

阻塞赋值语句使用等号`=`作为赋值符
前面的仿真中,initial里面的赋值语句都是用的阻塞赋值。

## 非阻塞赋值
非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。非阻塞赋值语句使用小于等于号`<=`作为赋值符。

利用下面代码，对阻塞、非阻塞赋值进行仿真，来说明2种过程赋值的区别。

```verilog
`timescale 1ns/1ns
module test;
    reg[3:0]    ai, bi;
    reg[3:0]    ai2, bi2;
    reg[3:0]    value_blk;
    reg [3:0]   value_non ;
    reg [3:0]   value_non2 ;

    initial begin
        ai            = 4'd1 ;   //(1)
        bi            = 4'd2 ;   //(2)
        ai2           = 4'd7 ;   //(3)
        bi2           = 4'd8 ;   //(4)
        #20 ;                    //(5)
 
        //non-block-assigment with block-assignment
        ai            = 4'd3 ;     //(6)
        bi            = 4'd4 ;     //(7)
        value_blk     = ai + bi ;  //(8)
        value_non     <= ai + bi ; //(9)
 
        //non-block-assigment itself
        ai2           <= 4'd5 ;           //(10)
        bi2           <= 4'd6 ;           //(11)
        value_non2    <= ai2 + bi2 ;      //(12)
    end
 
   //stop the simulation
    always begin
        #10 ;
        if ($time >= 1000) $finish ;
    end
 
endmodule
```


仿真结果如下:
语句(1) - (8)都是阻塞赋值，按照顺序执行。
20ns之前，信号ai,bi值改变，由于过程赋值的特点，value_blk=ai+bi并没有执行到，所以20ns之前，value_blk值为X(不确定状态)。

20ns之后，信号ai,bi值再次改变。执行到value_blk=ai+bi，信号value_blok利用信号ai,bi的新值得到计算结果7。

语句(9) - (12)都是非阻塞赋值，并行执行。
首先，(9) - (12)虽然都是并发执行，但是执行顺序也在(8)之后，素以信号value_non=ai+bi计算也会使用ai，bi的新值，结果为7。

其次，语句(10) - (12)是并发执行，所以value_non2=ai2+bi2计算时，并不关心信号ai2，bi2的最新非阻塞赋值结果。即value_non2计算时使用的时信号ai2，bi2的旧值，结果为4'hF。

## 使用非阻塞赋值避免竞争冒险
上面仿真代码只是为了更好理解阻塞赋值与非阻塞赋值的区别。实际verilog代码设计时，切记不要再一个过程结构种混合使用阻塞赋值与非阻塞赋值。两种赋值方式混用时，时序不容易控制，很容易得到意外的结果。

更多时候，在设计电路时，always时序逻辑块中多用非阻塞赋值，always组合逻辑块中多用阻塞赋值。

如下所示，为实现在时钟上升沿交换2个寄存器值的功能，在2个always块中使用阻塞赋值。

因为2个always块中的语句时同时进行的，但是a=b与b=a是无法判定执行顺序的，这就造成了竞争的局面。

但不管那个先执行(和编译器等有关系)，不考虑timing问题时，它们执行顺序总有先后，最后a与b的值总是相等的。没有达到交换2个寄存器值的效果。

```verilog
always @(posedge clk) begin
    a = b;
end

always @(posedge clk) begin
    b = a;
end
```

但是，如果在always块中使用非阻塞赋值，则可以避免上述竞争冒险的情况。
如下所示，2个always块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时a<=b, b<=a就可以相互不干扰的执行，达到交换寄存器值的目的。

```verilog
always @(posedge clk) begin
    a <= b;
end

always @(posedge clk) begin
    b <= a;
end
```

当然，利用下面代码也可以实现交换寄存器值的功能，但是显然不如在always块中直接用非阻塞赋值简单直观。

```verilog
always @(posedge clk) begin
    temp = a;
    a    = b;
    b    = temp;
end
```