# 2.3 Verilog数据类型
Verilog最常用的两种数据类型就是
> + 线网(wire)
> + 寄存器(reg)

其余类型可以理解为这两种数据类型的扩展或辅助。

## 线网(wire)
wire类型表示把硬件单元之间的物理连线，由其连接的器件输出连续驱动。如果没有驱动元件连接到wire型变量，缺省值一般为"Z"。举例如下:

```verilog
wire interrupt ;
wire flag1, flag2 ;
wire gnd = 1'db0 ;
```

线网型还有其他的数据类型，包括wand， wor，wri， triand， trior， trireg等，这些数据类型用的频率不是很高，这里不做介绍。

## 寄存器(reg)
寄存器(reg)用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下:

```verilog
reg clk_temp;
reg flag1, flag2;
```
例如在always块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成wire型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如:

```verilog
reg rstn ;
initial begin
    rstn = 1'b0 ;
    #100 ;         // 暂停100个时间单位
    rstn = 1'b1 ;
end
```

## 向量
当位宽大于1时，wire或reg即可声明为向量的形式。例如:
```verilog
reg [3:0]     counter ;     // 声明4bit位宽的寄存器counter
wire [32-1:0] gpio_data ;   // 声明32bit位宽的线型变量gpio_data
wire [8:2]    addr ;        // 声明为7bit位宽的线性变量addr，位宽范围为8:2
reg [0:31]    data ;        // 声明32bit位宽的寄存器变量data，最高有效位为0
```

对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如:

```verilog
wire [9:0] data_low = data[0:9] ;
addr_temp[3:2] = addr[8:7] + 1'b1 ;
```

Verilog支持可变的向量域选择，例如:
```verilog
reg [31:0]      data1 ;
reg [7:0]       btye1 [3:0];
integer j ;
always@* begin
    for (j=0; j<=3; j=j+1) begin
        byte1[j] = data1[(j+1)*8-1 : j*8];
    end
end
```

Verilog还支持指定bit位后固定位宽的向量域选择访问。
> + [bit+:width]:从起始bit位开始递增，位宽为width
> + [bit-:width]:从起始bit位开始递减，位宽为width

```verilog
//下面 2 种赋值是等效的
A = data1[31-: 8] ;
A = data1[31:24] ;

//下面 2 种赋值是等效的
B = data1[0+ : 8] ;
B = data1[0:7] ;
```

对信号重新组合成新的向量时，需要借助大括号。例如:
```verilog
wire [31:0]     temp1, temp2 ;
assign temp1 = {byte1[0][7:0], data1[31:8]};  // 数据拼接
assign temp2 = {32{1'b0}};  // 赋予32位的数值0
```

## 整数，实数，时间寄存器变量
整数、实数、时间等数据类型实际也属于寄存器类型。
**整数(integer)**
整数类型用关键字integer来声明。声明时不用指明位宽，位宽和编译器有关，一般未32bit。reg型变量为无符号数，而integer型变量为有符号数。

```verilog
reg [31:0]      data1 ;
reg [3:0]       byte1 [7:0] ;  // 数组变量，后续介绍
integer j ;                    // 整型变量，用来辅助生成数字电路
always@* begin
    for (j=0; j<=3; j=j+1) begin
        byte1[j] = data1[(j+1)*8-1 : j*8];
        end
end
```

此例中，integer信号j作为辅助信号，将data1的数据依次赋值给数组byte1。综合后实际电路里并没有j这个信号，j只是辅助生成相应的硬件电路。

**实数**
实数用关键字real来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为0。如果将一个实数赋给一个整数，则只有实数的整数部分会赋值给整数。例如:

```verilog
real        data1 ;
integer     temp ;
initial begin
    data1 = 2e3 ;
    data1 = 3.74 ;
end

initial begin
    temp = data1 ;  // temp的值为3
end
```

**时间**
Verilog使用特殊的时间寄存器time型变量，对仿真时间进行保存。其宽度一般为64bit，通过调用系统函数$time获取当前仿真时间。

```verilog
time    current_time ;
initial begin
    #100 ;
    current_time = $time ;  // current_time的大小为100
end
```

## 数组
在Verilog中允许声明reg,wire,integer,time,real及其向量类型的数组。

数组维度没有限制。现网数组也可以用于链接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如:<数组名>[<下标>]。对于多维数组来讲，用户需要说明其每一维的索引。

```verilog
integer     flag[7:0] ;  // 8个整数组成的数组
reg [3:0]   counter[3:0] ;  // 4个4bit计数器组成的数组
wire [7:0]  addr_bus[3:0] ;  // 4个8bit wire型变量组成的数组
wire        data_bit[7:0][5:0] ;  // 声明1bit wire型变量的二维数组
reg [31:0]  data_4d[11:0][3:0][3:0][255:0] ;  // 声明4维的32bit的数据变量数组
```
下面显示了对数组元素的赋值操作:
```verilog
flag [1] = 32'd0 ;  // 将flag数组中第二个元素赋值为32bit的0值
counter [3] = 4'hF ;  // 将数组counter中第4个元素的值赋值为4bit十六进制数F，等效于counter[3] [3:0] = 4'hF
assign addr_bus[0] = 8'b0 ;  // 将数组addr_bus中第一个元素赋值为0
assign data_bit[0][1] = 1'b1 ;  // 将数组data_bit的第一行第二列的元素赋值为1，这里不能省略掉第二个访问标号，即assign data_bit[0] = 1'b1; 是非法的。
data_4d[0][0][0][0] = 15'd3 ;  // 将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3。
```

虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为n；数组由多个元件组成，其中每个元件的位宽为n或1。它们在结构的定义上就有所区别。

## 存储器
存储器变量就是一种寄存器数组，可用来描述RAM或ROM的行为。例如:
```verilog
reg          membit[0:255];  // 256bit的1bit存储器
reg [7:0]    mem[0:1023] ;   // 1kbyte存储器，位宽8bit
mem[511] = 8'b0;             // 令第512个8bit的存储单元值为0
```

## 参数
参数用来表示常量，用关键字parameter声明，只能赋值一次。例如:
```verilog
parameter data_width = 10'd32;
parameter i=1, j=2, k=3 ;
parameter mem_size = data_width * 10;
```
但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。

局部参数用localparam来声明，起作用和用法与parameter相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用localparam来说明。

## 字符串
字符串保存在reg类型的变量中，每个字符占用一个字节(8bit)。因此寄存器变量的宽度应该足够大，以保证不会溢出。

字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用0来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串"run.runoob.com"，需要14*8bit的存储单元。

```verilog
reg [0:14*8-1] str ;
initial begin
    str = "run.runoob.com";
end
```

有一些特殊字符在显示字符串中由特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前缀转义字符\。

其实，在SystemVerilog(主要用于Verilog仿真的编程语言中)语言中，已经可以直接用关键字string来表示字符串变量类型，这为Verilog的仿真带来了极大的便利。