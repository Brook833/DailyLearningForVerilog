# 2.5 Verilog编译指令
以反引号`开始的某些标识符是Verlog系统编译指令。
编译指令为Verilog代码的撰写、编译、调试等提供了极大的便利。
下面介绍完整的8种编译指令，其中前4种使用频率较高。

## `define, `undef
在编译阶段，`define用于文本替换，类似于C语言中的#define。
一旦`define指令被编译，其在整个编译过程中都会有效。例如，在一个文件中定义:

```verilog
`define DATA_DW 32
```

则在另一个文件中也可以直接使用DATA_DW。

```verilog
`define S $stop;
// 用`S来代替系统函数$stop;(包括分号)
`define WORD_DEF reg[31:0]
// 可以用`WORD_DEF来声明32bit寄存器变量
```

`undef用来取消之前的宏定义，例如:

```verilog
`define DATA_DW 32
......
reg [DATA_DW-1:0] data_in;
......
`undef DATA_DW

`ifdef, `ifndef, `elsif, `else, `endif
```

这是属于条件编译的指令。例如下面的例子中，如果定义了MCU51，则使用第一种参数说明；如果没有定义MCU，定义了WINDOW，则使用第二种参数说明；如果2个都没有定义，则使用第三种参数说明。

```verilog
`ifdef MCU51
    parameter DATA_DW = 8;
`elsif  WINDOW
    parameter DATA_DW = 64;
`else
    parameter DATA_DW = 32;
`endif
```

`elsif, `else编译指令对于`ifdef指令是可选的，既可以只有`ifdef组成一次条件编译指令块。

当然，也可用`ifndef来设置条件编译。

下面例子中，如果定义了WINDOW，则使用第二中参数说明。如果没有定义WINDOW，则使用第一种参数说明。

```verilog
`ifndef WINDOW
    parameter DATA_DW = 32;
`else
    parameter DATA_DW = 64;
`endif
```

## `include
使用`include可以在编译时将一个Verilog文件内嵌到另一个Verilog我呢见中，作用类似于C语言中的#include结构。该指令通常用于将全局或公用的头文件包含在设计文件里。

文件路径既可以使用相对路径，也可以使用绝对路径。

```verilog
`include "../../param.v"
`include "header.v"
```

## `timescal
在Verilog模型中，时延有具体的单位时间表述，并用`timescale编译指令将时间单位于实际单位相关联。

该指令用于定义时延，仿真的单位和精度，格式为:

```verilog
`timescale      time_unit / time_precision
```

time_unit表示时间单位，time_precision表示时间精度，它们均是由数字以及单位s(秒),ms(毫秒),us(微妙),ns(纳秒),ps(皮秒)和fs(飞秒)组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端Z会延迟5.21ns输出A&B的结果。

```verilog 
`timescale 1ns/100ps  //时间单位为1ns，精度为100ps，合法
// timesca;e 100ps/1ns  // 不合法
module AndFunc(Z, A, B);
    output Z;
    input A, B;
    assign #5.207 Z = A&B
endmodule
```

在编译过程中，`timescale指令会影响后面你所有模块中的时延值，直至遇到另一个`timescale指令或`resetall指令。

在编译过程中，`timescale指令会音响后买你所有的模块中的时延值，直至遇到另一个`timescale指令或`resetall指令。

由于在Verilog中没有默认的`timescale，如果没有指定`timescale，Verilog模块就有会继承前面编译模块`timescale参数。有可能设计出错。

如果一个设计中的多个模块都带有`timescale时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度，时延单位并不受影响。例如:

```verilog
`timescale 10ns/1ns
module test;
    reg A, B;
    wire OUTZ;

    initial begin
        A = 1;
        B = 0;
        # 1.28 B = 1;
        # 3.1  A = 0;
    end

    AndFunc u_and(OUTZ, A, B);
endmodule
```

在模块AndFunc中，5.207对应5.21ns。
在模块test中，1.28对应13ns，3.1对应31ns。

但是，当仿真test时，由于AndFunc中的最小精度为100ps，因此test中的时延将进行重新调整。13ns将对应130*100ps，31ns将对应310 *100ps。仿真时，时延精度也会使用100ps。仿真时间单位大小没有影响。

如果有并行子模块，子模块间的`timescale并不会互相影响。

例如在模块test中再梨花一个子模块OrFunc。仿真test时，OrFunc中的#5.207延时依然对应52ns。

```verilog
// 子模块
`timescale 10ns/1ns //时间单位为1ns，精度为100ps，合法
module OrFunc(Z, A, B);
    output  Z;
    intput  A, B;
    assign #5.207 Z = A | B;
endmodule

//顶层模块：
`timescale 10ns/1ns      
module test;
    reg        A, B ;
    wire       OUTZ ;
    wire       OUTX ;
 
    initial begin
        A     = 1;
        B     = 0;
        # 1.28    B = 1;
        # 3.1     A = 0;
    end
    AndFunc        u_and(OUTZ, A, B) ;
    OrFunc         u_and(OUTX, A, B) ;
endmodule
```

此例中，仿真test时，OrFunc中的#5.207延时依然对应52ns。

`timescale的时间精度设置是会影响仿真时间的。时间精度越小，仿真时占用内存越多，实际使用的仿真时间就越长。所以如果没有必要，应尽量将时间精度设置的大一些。

## `default_nettype
该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。

```verilog
`default_nettype wand
```

该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。

```verilog
`default_nettype none
```

该实例定义后，将不再自动产生wire型变量。
例如下面第一种写法编译时不会报Error，第二种写法编译将不会通过。

```verilog
// Z1 无定义就使用，系统默认Z1为wire型变量，有Warning无Error
module test_and(
        input   A,
        input   B,
        output  Z);
    assign Z1 = A & B;
endmodule
```

```verilog
//Z1 无定义就使用，由于编译指令的存在，系统就会报Error，从而检查出书写错误
`default_nettype none
module test_and(
        input   A,
        input   B,
        output  Z);
    assign Z1 = A & B;
endmodule
```

## `resetall
该编译器指令将所有的编译指令重新设置为缺省值。
`resetall可以使得缺省连线类型为线网类型。
当`resetall加到模块最后时，可以将当前的`timescale取消防止进一步传递，只保证当前的`timescale在局部有效，避免`timescale的错误继承。

## `celldefine, `endcelldefine
这两个程序指令用于将模块标记为单元模块，它们包含模块的定义。例如一些与、或、非门，一些PLL单元，PAD模型，以及一些Analog IP等。

```verilog
`celldefine
module (
    input   clk,
    input   rst,
    output  clk_pll,
    output  flag);

endmodule
`endcelldefine
```

## `unconnected_drive, `nounconnected_drive
在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。

```verilog
`unconnected_drive pu111
...
/ *在这两个程序指令间的所有未连接的输入端口为正偏电路状态（连接到高电平） * /
 `nounconnected_drive
```

```verilog
`unconnected_drive pull0
. . .
/ *在这两个程序指令间的所有未连接的输入端口为反偏电路状态（连接到低电平） * /
`nounconnected_drive 
```

 