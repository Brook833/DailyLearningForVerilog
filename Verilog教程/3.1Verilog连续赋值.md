# 3.1 Verilog连续赋值
## 关键词 assign, 全加器
连续赋值语句是Verilog数据流建模的基本语句，用于对wire型变量进行赋值。

```verilog
assign LHS_target = RHS_expression;
```

LHS (left hand)只赋值操作的左侧，RHS (right hand side)指赋值操作的右侧。

LHS指值赋值操作的左测，RHS指赋值操作的右侧。

assign为关键词，任何已经声明wire变量的连续赋值语句都是以assign开头，例如:

```verilog
wire    Cout, A, B;
assign  Cout = A & B;  // 实现计算A与B的功能
```

需要说明的是:
> + LHS_target必须是一个标量或者线型向量，而不能是寄存器类型。
> + RHS_expression的类型没有要求，可以是标量或者线型或寄存器向量，也可以是函数调用。
> + 只要RHS_expression表达式的操作数有事件发生(值的变化)时，RHS_expression就会立刻重新计算，同时赋值给LHS_target。

Verilog还提供了另一对wire型赋值的简单方法，即在wire型变量声明的时候同时对其赋值。wire型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。例如下面赋值方式和上面的赋值例子的赋值方式，效果都是一致的。

```verilog
wire A, B;
wire Cout = A & B;
```

## 全加器
下面采用数据流描述方式，来设计一个1bit全加器。
设Ai, Bi, Ci分别为被加数，加数和相邻低位的进位数，So,Co分别为本位和相邻高位的进位数。

真值表如下:

| Input |  |  | Output |  |
|:- |:- |:- |:- |:- |
| Ci | Ai | Bi | So | Co |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

全加器的表达式:

```verilog
So = Ai + Bi + Ci;
Co = AiBi + Ci(Ai + Bi);
```

rtl代码(full_adder1.v)如下:

```verilog
module full_adder1(
    input Ai, Bi, Ci,
    output So,Co);

    assign So = Ai ^ Bi ^Ci;
    assign Co = (Ai & Bi) | (Ci & (Ai | Bi));
endmodule
```

当然，更为贴近加法器的代码描述可以为:

```verilog
module full_adder1(
    input  Ai, Bi, Ci
    output So, Co);

    assign {Co, So} = Ai + Bi + Ci;
endmodule
```
